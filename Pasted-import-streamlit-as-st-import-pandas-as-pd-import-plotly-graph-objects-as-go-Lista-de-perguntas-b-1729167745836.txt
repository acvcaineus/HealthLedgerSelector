import streamlit as st
import pandas as pd
import plotly.graph_objects as go

# Lista de perguntas baseadas na Pilha Shermin Adaptada
questions = {
    "Aplicação": [
        "A aplicação exige alta segurança e controle?",
        "A aplicação precisa de alta eficiência operacional?"
    ],
    "Consenso": [
        "A rede exige escalabilidade e governança flexível?",
        "A rede precisa de alta segurança e descentralização de dados críticos?"
    ],
    "Infraestrutura": [
        "A infraestrutura precisa lidar com alta escalabilidade em redes IoT?",
        "A rede precisa de alta segurança e descentralização de dados críticos?"
    ],
    "Internet": [
        "A rede exige integração com sistemas legados de saúde?",
        "A aplicação requer monitoramento em tempo real de dispositivos IoT?"
    ]
}

# Dados de exemplo para DLTs e Algoritmos por Cenário e Pesos
dlt_data = {
    'EMR': {
        'DLT': ['Hyperledger Fabric', 'Ethereum', 'IOTA (DAG)', 'Bitcoin'],
        'Segurança': [9, 8, 7, 10],
        'Escalabilidade': [7, 8, 9, 3],
        'Eficiência Energética': [6, 7, 9, 2],
        'Governança': [7, 9, 8, 5]
    },
    'Cadeia de Suprimentos': {
        'DLT': ['Hyperledger Fabric', 'VeChain', 'Ethereum', 'IOTA (DAG)'],
        'Segurança': [9, 7, 8, 7],
        'Escalabilidade': [7, 9, 8, 9],
        'Eficiência Energética': [6, 9, 7, 9],
        'Governança': [7, 8, 9, 8]
    }
}

# Função para definir pesos dos requisitos
def define_weights():
    st.title("Defina os Pesos para os Requisitos")
    st.write("Atribua um valor de 0 a 10 para cada requisito com base na sua importância.")
    
    weights = {}
    weights["Segurança"] = st.slider("Peso de Segurança", 0, 10, 5)
    weights["Escalabilidade"] = st.slider("Peso de Escalabilidade", 0, 10, 5)
    weights["Eficiência Energética"] = st.slider("Peso de Eficiência Energética", 0, 10, 5)
    weights["Governança"] = st.slider("Peso de Governança", 0, 10, 5)
    
    return weights

# Função para selecionar cenários com base nos pesos
def select_scenario(weights):
    st.title("Selecione o Cenário de Aplicação")
    
    # Aplica os pesos para priorizar os cenários
    scenario_scores = {}
    for scenario, metrics in dlt_data.items():
        score = 0
        for metric, weight in weights.items():
            score += sum([m * weight for m in metrics[metric]]) / len(metrics[metric])
        scenario_scores[scenario] = score
    
    sorted_scenarios = sorted(scenario_scores, key=scenario_scores.get, reverse=True)
    st.write("Cenários Prioritários com Base nos Pesos Definidos:")
    scenario_choice = st.selectbox("Selecione o Cenário", sorted_scenarios)
    
    return scenario_choice

# Função para processar as perguntas da Pilha Shermin Adaptada
def ask_shermin_questions():
    st.title("Responda às Perguntas para Refinar a Recomendação")
    st.write("Essas perguntas ajudarão a determinar a DLT mais adequada com base nas camadas da Pilha Shermin.")

    user_answers = {}

    for layer, qs in questions.items():
        st.subheader(f"Camada: {layer}")
        for q in qs:
            user_answers[q] = st.radio(q, options=["Sim", "Não"])

    return user_answers

# Função para gerar recomendação final com base nas respostas e pesos
def generate_recommendation(scenario, weights, user_answers):
    st.title("Recomendação Final Baseada em Prioridades e Respostas")
    
    # Acessa os dados de DLT para o cenário selecionado
    dlt_df = pd.DataFrame(dlt_data[scenario])
    
    # Calcula o score final com base nos pesos e respostas
    dlt_scores = {}
    for i, dlt in enumerate(dlt_df['DLT']):
        score = 0
        for metric, weight in weights.items():
            score += dlt_df[metric][i] * weight
        dlt_scores[dlt] = score

    # Ordena as DLTs com base nas pontuações
    recommended_dlts = sorted(dlt_scores, key=dlt_scores.get, reverse=True)
    
    # Exibe as tomadas de decisão e recomendação final
    st.subheader("Decisões Tomadas Durante o Processo:")
    for q, ans in user_answers.items():
        st.write(f"{q}: **{ans}**")
    
    st.subheader("DLT Recomendada:")
    st.write(f"A DLT recomendada é: **{recommended_dlts[0]}**")
    
    st.subheader("Outras DLTs possíveis:")
    for dlt in recommended_dlts[1:]:
        st.write(f"- {dlt}")

# Função principal da aplicação
def main():
    st.sidebar.title("SeletorDLTSaude")
    st.sidebar.write("Selecione as etapas para configurar sua recomendação.")
    
    # Define as etapas da aplicação
    step = st.sidebar.selectbox("Etapa", ["Definir Pesos", "Escolher Cenário", "Responder Perguntas", "Receber Recomendação"])
    
    # Armazenar as seleções do usuário
    if step == "Definir Pesos":
        st.session_state.weights = define_weights()
    
    elif step == "Escolher Cenário":
        if 'weights' not in st.session_state:
            st.error("Por favor, defina os pesos primeiro.")
        else:
            st.session_state.scenario_choice = select_scenario(st.session_state.weights)
    
    elif step == "Responder Perguntas":
        if 'scenario_choice' not in st.session_state:
            st.error("Por favor, escolha um cenário primeiro.")
        else:
            st.session_state.user_answers = ask_shermin_questions()
    
    elif step == "Receber Recomendação":
        if 'user_answers' not in st.session_state:
            st.error("Por favor, responda às perguntas primeiro.")
        else:
            generate_recommendation(st.session_state.scenario_choice, st.session_state.weights, st.session_state.user_answers)

if __name__ == "__main__":
    main()
